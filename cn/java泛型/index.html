<!doctype html>
<html lang="cn"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Java泛型 - 海&#039;s Blog</title><link rel="manifest" href="../../manifest.json"><meta name="application-name" content="海&#039;s Blog"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="海&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="java泛型简介 Oracle官网中对于java泛型的描述： https:&amp;#x2F;&amp;#x2F;docs.oracle.com&amp;#x2F;javase&amp;#x2F;tutorial&amp;#x2F;java&amp;#x2F;generics&amp;#x2F;why.html 泛型的用处：泛型使类型（类和接口）在定义类、接口和方法时成为参数，从而使相同的一段代码处理多种不同类型的传入数据"><meta property="og:type" content="article"><meta property="og:title" content="Java泛型"><meta property="og:url" content="https://blog.mockingj.cn/cn/java%E6%B3%9B%E5%9E%8B/"><meta property="og:site_name" content="海&#039;s Blog"><meta property="og:description" content="java泛型简介 Oracle官网中对于java泛型的描述： https:&amp;#x2F;&amp;#x2F;docs.oracle.com&amp;#x2F;javase&amp;#x2F;tutorial&amp;#x2F;java&amp;#x2F;generics&amp;#x2F;why.html 泛型的用处：泛型使类型（类和接口）在定义类、接口和方法时成为参数，从而使相同的一段代码处理多种不同类型的传入数据"><meta property="og:locale" content="cn"><meta property="og:image" content="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/%E6%B6%88%E5%A4%B1%E7%9A%84%E7%A4%BE%E7%BE%A4/IMG_0875.jpeg"><meta property="article:published_time" content="2021-07-31T16:00:00.000Z"><meta property="article:modified_time" content="2021-07-31T16:00:00.000Z"><meta property="article:author" content="Ceacar"><meta property="article:tag" content="java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/%E6%B6%88%E5%A4%B1%E7%9A%84%E7%A4%BE%E7%BE%A4/IMG_0875.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.mockingj.cn/cn/java%E6%B3%9B%E5%9E%8B/"},"headline":"Java泛型","image":[],"datePublished":"2021-07-31T16:00:00.000Z","dateModified":"2021-07-31T16:00:00.000Z","author":{"@type":"Person","name":"Ceacar"},"publisher":{"@type":"Organization","name":"海's Blog","logo":{"@type":"ImageObject","url":"https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/IMG_1703.jpeg"}},"description":"java泛型简介 Oracle官网中对于java泛型的描述： https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;tutorial&#x2F;java&#x2F;generics&#x2F;why.html 泛型的用处：泛型使类型（类和接口）在定义类、接口和方法时成为参数，从而使相同的一段代码处理多种不同类型的传入数据"}</script><link rel="canonical" href="https://blog.mockingj.cn/cn/java%E6%B3%9B%E5%9E%8B/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="../../css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="../../index.html"><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/IMG_1703.jpeg" alt="海&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="../../index.html">Home</a><a class="navbar-item" href="../../archives">Archives</a><a class="navbar-item" href="../../categories">Categories</a><a class="navbar-item" href="../../tags">Tags</a><a class="navbar-item" href="../../about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/%E6%B6%88%E5%A4%B1%E7%9A%84%E7%A4%BE%E7%BE%A4/IMG_0875.jpeg" alt="Java泛型"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-31T16:00:00.000Z" title="2021/8/1 上午12:00:00">2021-08-01</time>发表</span><span class="level-item"><time dateTime="2021-07-31T16:00:00.000Z" title="2021/8/1 上午12:00:00">2021-08-01</time>更新</span><span class="level-item"><a class="link-muted" href="../../categories/java/">java</a></span><span class="level-item">21 minutes读完 (大约3139个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java泛型</h1><div class="content"><h2 id="java泛型简介">java泛型简介</h2>
<p>Oracle官网中对于java泛型的描述：</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/why.html">https://docs.oracle.com/javase/tutorial/java/generics/why.html</a></p>
<p>泛型的用处：泛型使类型（类和接口）在定义类、接口和方法时成为参数，从而使相同的一段代码处理多种不同类型的传入数据</p>
<span id="more"></span>
<p>来自官网的例子，使用泛型的函数或类使用的形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(<span class="number">0</span>);   <span class="comment">// no cast</span></span><br></pre></td></tr></table></figure>
<p>而没有使用泛型时，需要强制转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>java中的List接口，提供对不同类型的类的标准方法。想象一下，若没有java泛型，则只能使用强制转换，并带来某些问题。</p>
<p>对于其中的get()函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList.java</span><br><span class="line">    </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>可见此函数直接返回容器内的类，不需要强制转换的步骤，程序更加安全。</p>
<p>泛型使程序员能够实现通用算法。 通过使用泛型，程序员可以实现适用于不同类型集合的泛型算法，安全且易于阅读</p>
<h2 id="java泛型类">java泛型类</h2>
<p>java创建泛型类的原因是为了容器类的实现。</p>
<p>容器类是用来保存对象的，将对象放入其中，并对放入的一个或多个对象进行操作，如排序，增加，删除，查找等。这就要求容器类需要接收不同类型的类。所以必须使用一个机制，使容器类对所有的类都来者不拒。泛型类应运而生。</p>
<h3 id="java泛型类简介">java泛型类简介</h3>
<p>举个例子，假设定义一个简单的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object object)</span> &#123; <span class="built_in">this</span>.object = object; &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> object; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的类存在的问题：此类的功能时接收一个类和返回接收的类，所以可能导致接收的类和期望返回的类（可能使用强制转换）不是同一个类型，导致运行时错误。同时在编译时此类错误无法被识别。</p>
<p>于是，改写为java泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generic version of the Box class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the value being boxed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// T stands for &quot;Type&quot;</span></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123; <span class="built_in">this</span>.t = t; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java泛型类保证了传入的类型和期望返回的类型是相同的。使用“public class Box<T>”来创建泛型声明，这引入了类型变量 T，代表传入对象的类型。</p>
<h3 id="java泛型类的定义">java泛型类的定义</h3>
<p>java泛型类使用如下格式定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">name</span>&lt;T1, T2, ..., Tn&gt; &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>类型参数部分由尖括号 (&lt;&gt;) 分隔，跟在类名之后。 它指定类型参数（也称为类型变量）T1、T2、…和 Tn。</p>
<p>在java的文档上有一个类型参数命名约定：</p>
<ul>
<li>E - Element</li>
<li>K - Key</li>
<li>N - Number</li>
<li>T - Type</li>
<li>V - Value</li>
<li>S,U,V etc. - 2nd, 3rd, 4th types</li>
</ul>
<h3 id="java泛型类使用">java泛型类使用</h3>
<p>以Box泛型类为例，要从代码中引用泛型 Box 类，您必须执行泛型类型调用，它将 T 替换为一些具体值，例如 Integer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox;</span><br></pre></td></tr></table></figure>
<p>可以将泛型类型调用视为类似于普通方法调用，但不是将参数传递给方法，而是将类型参数（在本例中为 Integer）传递给 Box 类本身</p>
<p>与任何其他变量声明一样，此代码实际上并未创建新的 Box 对象。 它只是声明 integerBox 将保存对“Box of Integer”的引用，这就是 Box<Integer> 的读取方式。 泛型类型的调用通常称为参数化类型。 要实例化这个类，像往常一样使用 new 关键字，但将 <Integer> 放在类名和括号之间:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;Integer&gt;();<span class="comment">//泛型的实例化</span></span><br></pre></td></tr></table></figure>
<h2 id="java泛型函数">java泛型函数</h2>
<h3 id="java泛型函数简介">java泛型函数简介</h3>
<p>和java泛型类类似，泛型函数通过引入所在类的类型参数。类型参数的范围仅限于声明它的方法。 允许使用静态和非静态泛型方法，以及泛型类构造函数。</p>
<h3 id="java泛型函数定义">java泛型函数定义</h3>
<p>泛型方法的语法包括一个类型参数列表，在尖括号内,它出现在方法的返回类型之前，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  &lt;K, V&gt;  <span class="type">boolean</span> <span class="title function_">function</span><span class="params">(K k,V v)</span></span><br></pre></td></tr></table></figure>
<p>对于静态泛型方法，类型参数部分必须出现在方法的返回类型之前,例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Util</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getKey().equals(p2.getKey()) &amp;&amp;</span><br><span class="line">               p1.getValue().equals(p2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型函数可以使用泛型类中的类型参数，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;K, V&gt; &#123;<span class="comment">//泛型类声明</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K key;<span class="comment">//使用类型参数</span></span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(K key)</span> &#123; <span class="built_in">this</span>.key = key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(V value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span>   &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有界类型参数">有界类型参数</h2>
<h3 id="有界类型参数简介">有界类型参数简介</h3>
<p>在使用java泛型的时候，可能会希望限制用作参数化类型中的类型参数的类型，也就是限制传入类的类型种类。譬如，只接受<strong>Number类型及其子类</strong>的对象作为实例化参数。这就是有界类型参数的用途。</p>
<h3 id="有界类型参数的定义">有界类型参数的定义</h3>
<p>形如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T <span class="keyword">extends</span> <span class="title class_">Integer</span>&gt;</span><br></pre></td></tr></table></figure>
<p>称为有界类型参数</p>
<p>直接上示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T t;          </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;U <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">void</span> <span class="title function_">inspect</span><span class="params">(U u)</span>&#123;	<span class="comment">//有界类型参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;T: &quot;</span> + t.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;U: &quot;</span> + u.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;Integer&gt;();</span><br><span class="line">        integerBox.set(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>));</span><br><span class="line">        integerBox.inspect(<span class="string">&quot;some text&quot;</span>); <span class="comment">// error: this is still String!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在编译阶段会检查inspect函数中传输的参数类型，并给出错误提示，以保证传入的类型是Number及其子类。</p>
<p>同样也可以在java泛型类声明的时候使用有界类型参数，在编译此类型参数在类中的函数使用参数类型T的时候进行检查，保证类中所有使用T的函数都符合限定的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NaturalNumber</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Integer</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NaturalNumber</span><span class="params">(T n)</span>  &#123; <span class="built_in">this</span>.n = n; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEven</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n.intValue() % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重有界类型参数的定义">多重有界类型参数的定义</h3>
<p>前面的示例说明了使用具有单个边界的类型参数，但类型参数可以具有多个边界</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T <span class="keyword">extends</span> <span class="title class_">B1</span> &amp; B2 &amp; B3&gt;</span><br></pre></td></tr></table></figure>
<p>具有多个边界的类型变量是边界中列出的所有类型的子类型。如果边界之一是类，则必须首先指定它</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class A &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &lt;T <span class="keyword">extends</span> <span class="title class_">A</span> &amp; B &amp; C&gt; &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>如果未首先指定绑定 A，则会出现编译时错误</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &lt;T <span class="keyword">extends</span> <span class="title class_">B</span> &amp; A &amp; C&gt; &#123; <span class="comment">/* ... */</span> &#125;  <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>
<h2 id="泛型的继承和子类">泛型的继承和子类</h2>
<p>如您所知，只要类型兼容，就可以将一种类型的对象分配给另一种类型的对象。</p>
<p>泛型也是如此。您可以执行泛型类型调用，将 Number 作为其类型参数传递，如果参数与 Number 兼容，则允许任何后续的 add 调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Number&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;Number&gt;();</span><br><span class="line">box.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>));   <span class="comment">// OK</span></span><br><span class="line">box.add(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">10.1</span>));  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p>看看下面的示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">boxTest</span><span class="params">(Box&lt;Number&gt; n)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>boxTest接受一个类型为Box<Number>的参数，但在使用中不能传入Box<Integer>或者Box<Double>，因为不是Box<Number>的子类型。</p>
<p>所以可以有这样一张图：</p>
<p><img src="https://docs.oracle.com/javase/tutorial/figures/java/generics-subtypeRelationship.gif" alt=""></p>
<p>给定两个具体类型 A 和 B（例如，Number 和 Integer）。</p>
<p>无论 A 和 B 是否相关，<code>MyClass&lt;A&gt;</code>与 <code>MyClass&lt;B&gt; </code>都没有关系。</p>
<p><code>MyClass&lt;A&gt; </code>和 <code>MyClass&lt;B&gt;</code> 的共同父对象是 Object。</p>
<p>那么，java泛型类有怎样的继承关系呢：</p>
<p><img src="https://docs.oracle.com/javase/tutorial/figures/java/generics-sampleHierarchy.gif" alt=""></p>
<p>以 Collections 类为例，ArrayList<E> 实现了 List<E>，而 List<E> 扩展了 Collection<E>。 所以 ArrayList<String> 是 List<String> 的子类型，List<String> 是 Collection<String> 的子类型。 只要不改变类型参数，类型之间的子类型关系就会保留。</p>
<p>若泛型类存在多个类型参数，也可以从但类型参数的泛型类中继承</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PayloadList</span>&lt;E,P&gt; <span class="keyword">extends</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setPayload</span><span class="params">(<span class="type">int</span> index, P val)</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PayloadList 的以下参数化是 List<String> 的子类型</p>
<ul>
<li><code>PayloadList&lt;String,String&gt;</code></li>
<li><code>PayloadList&lt;String,Integer&gt;</code></li>
<li><code>PayloadList&lt;String,Exception&gt;</code></li>
</ul>
<p>它们的关系如图所示</p>
<p><img src="https://docs.oracle.com/javase/tutorial/figures/java/generics-payloadListHierarchy.gif" alt=""></p>
<h2 id="java通配符">java通配符</h2>
<p>在java泛型中，称为<em>通配符的</em>问号 ( <code>?</code> )表示未知类型。通配符可用于多种情况：作为参数、字段或局部变量的类型；有时作为返回类型。通配符永远不会用作泛型方法调用、泛型类实例创建或超类型的类型参数。</p>
<h3 id="上界通配符">上界通配符</h3>
<p>在Java编程中，可以使用上界通配符来放宽对类型参数的限制。</p>
<p>举一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(List&lt;? extends Foo&gt; list)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>上界通配符，<code>&lt;? extends Foo&gt; </code>，其中Foo是任何类型的，匹配Foo和任何Foo的子类。下列process方法代码可以遍历使用list容器的Foo对象或者Foo类的子类对象的List容器类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(List&lt;? extends Foo&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Foo elem : list) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无界通配符">无界通配符</h3>
<p>无界通配符类型使用通配符 ( <code>?</code> )指定，例如<code>List&lt;?&gt;</code>。这称为<em>未知类型列表</em>。在两种情况下，无界通配符是一种有用的方法：</p>
<ul>
<li>如果您正在编写可以使用<code>Object</code>类中提供的功能实现的方法。</li>
<li>当代码不依赖于泛型类中的类型参数时。例如，<code>List.size</code>或<code>List.clear</code>。事实上，<code>Class&lt;?&gt;</code>之所以如此常用，是因为<code>Class&lt;T&gt; 中的</code>大多数方法都不依赖于<code>T</code>。</li>
</ul>
<p>内部没有使用T或者其他类型参数的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object elem: list)</span><br><span class="line">        System.out.print(elem + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="下界通配符">下界通配符</h3>
<p>下界通配符将未知类型限制为特定类型或该类型的父类型</p>
<p>以下代码将数字 1 到 10 添加到列表的末尾，该方法适用于<code>List&lt;Integer&gt;</code>、<code>List&lt;Number&gt;</code>和<code>List&lt;Object&gt;</code> 以及任何可以保存<code>Integer</code>值的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addNumbers</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有关于通配符的子类型">有关于通配符的子类型</h3>
<p>如泛型的继承和子类中所述，泛型类或接口之间的关系不仅仅因为它们的类型之间存在关系。但是可以使用通配符来创建通用类或接口之间的关系。</p>
<p>给定两个非泛型类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>编写下列代码是正确的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> b;</span><br></pre></td></tr></table></figure>
<p>此示例显示常规类的继承遵循此子类型规则：如果<code>B</code>扩展<code>A ，</code>则类<code>B</code>是类<code>A</code>的子类型。此规则不适用于泛型类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;B&gt; lb = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;A&gt; la = lb;   <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>
<p>上述代码可以看出<code>List&lt;B&gt;</code>并不是<code>List&lt;A&gt;</code>的子类型</p>
<p>于是在学习了java通配符后，有这么一种关系：</p>
<p><img src="https://docs.oracle.com/javase/tutorial/figures/java/generics-listParent.gif" alt=""></p>
<p>List<Numbger>和List<Integer>共同的父级是<code>List&lt;?&gt;</code>,而List<Number>和List<Integer>之间没有关系。</p>
<p>为了在这些类之间创建关系，以便代码可以通过<code>List&lt;Integer&gt;</code>的元素访问<code>Number</code>的方法，请使用上限通配符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Integer</span>&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;  numList = intList;  <span class="comment">// OK. List&lt;? extends Integer&gt; is a subtype of List&lt;? extends Number&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>Integer</code>是<code>Number</code>的子类型，而<code>numList</code>是<code>Number</code>对象的列表，所以现在<code>intList</code>（<code>Integer</code>对象的列表）和<code>numList</code>之间存在关系。下图显示了使用上限和下限通配符声明的几个<code>List</code>类之间的关系。</p>
<p>根据上述规则可以列出通用List类声明的层次结构</p>
<p><img src="https://docs.oracle.com/javase/tutorial/figures/java/generics-wildcardSubtyping.gif" alt=""></p>
<h2 id="对泛型的限制">对泛型的限制</h2>
<ul>
<li>无法使用原始类型实例化泛型类型</li>
<li>无法创建类型参数的实例</li>
<li>不能声明类型为类型参数的静态字段</li>
<li>不能对参数化类型使用 Casts 或<code>instanceof</code></li>
<li>无法创建参数化类型的数组</li>
<li>无法创建、捕获或抛出参数化类型的对象</li>
<li>无法将每个重载的形式参数类型擦除为相同原始类型的方法重载</li>
</ul>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="../../tags/java/">java</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="../%E8%AE%B0%E4%B8%80%E6%AC%A1Springboot+mybaits%E9%85%8D%E7%BD%AE%E7%BB%8F%E5%8E%86/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">记一次Springboot+mybaits配置经历</span></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#java泛型简介"><span class="level-left"><span class="level-item">1</span><span class="level-item">java泛型简介</span></span></a></li><li><a class="level is-mobile" href="#java泛型类"><span class="level-left"><span class="level-item">2</span><span class="level-item">java泛型类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#java泛型类简介"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">java泛型类简介</span></span></a></li><li><a class="level is-mobile" href="#java泛型类的定义"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">java泛型类的定义</span></span></a></li><li><a class="level is-mobile" href="#java泛型类使用"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">java泛型类使用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#java泛型函数"><span class="level-left"><span class="level-item">3</span><span class="level-item">java泛型函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#java泛型函数简介"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">java泛型函数简介</span></span></a></li><li><a class="level is-mobile" href="#java泛型函数定义"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">java泛型函数定义</span></span></a></li></ul></li><li><a class="level is-mobile" href="#有界类型参数"><span class="level-left"><span class="level-item">4</span><span class="level-item">有界类型参数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#有界类型参数简介"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">有界类型参数简介</span></span></a></li><li><a class="level is-mobile" href="#有界类型参数的定义"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">有界类型参数的定义</span></span></a></li><li><a class="level is-mobile" href="#多重有界类型参数的定义"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">多重有界类型参数的定义</span></span></a></li></ul></li><li><a class="level is-mobile" href="#泛型的继承和子类"><span class="level-left"><span class="level-item">5</span><span class="level-item">泛型的继承和子类</span></span></a></li><li><a class="level is-mobile" href="#java通配符"><span class="level-left"><span class="level-item">6</span><span class="level-item">java通配符</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#上界通配符"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">上界通配符</span></span></a></li><li><a class="level is-mobile" href="#无界通配符"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">无界通配符</span></span></a></li><li><a class="level is-mobile" href="#下界通配符"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">下界通配符</span></span></a></li><li><a class="level is-mobile" href="#有关于通配符的子类型"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">有关于通配符的子类型</span></span></a></li></ul></li><li><a class="level is-mobile" href="#对泛型的限制"><span class="level-left"><span class="level-item">7</span><span class="level-item">对泛型的限制</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="../../js/toc.js" defer></script></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="../../tags/Hive%E5%BC%80%E5%8F%91/"><span class="tag">Hive开发</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/blog/"><span class="tag">blog</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/go/"><span class="tag">go</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/hugo/"><span class="tag">hugo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/java/"><span class="tag">java</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/java%E5%AD%A6%E4%B9%A0/"><span class="tag">java学习</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/java%E5%BC%80%E5%8F%91/"><span class="tag">java开发</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/mybaits/"><span class="tag">mybaits</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/springboot/"><span class="tag">springboot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/%E9%9A%8F%E6%83%B3/"><span class="tag">随想</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="../../index.html"><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/IMG_1703.jpeg" alt="海&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Ceacar</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="../../js/column.js"></script><script src="../../js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><script src="../../js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="../../js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"../../content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>