<!doctype html>
<html lang="cn"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Java线程池初探 - 海&#039;s Blog</title><link rel="manifest" href="../../manifest.json"><meta name="application-name" content="海&#039;s Blog"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="海&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="简介 在日常的程序编写中，经常会用到一种思想——池化，也就是将资源整合成一个资源池并作统一的分配。在此文章中，线程池就是这一思想的具体体现。 在普通的线程创建中，是直接创建线程，会存在  频繁申请销毁资源 调度资源造成额外的损耗 无限申请资源和缺少内部资源管理等问题  为解决以上问题，采用池化的思想，将线程统一管理。使得单一线程可以在执行完一个任务后而不被销毁，并继续执行下一个任务。 在java中"><meta property="og:type" content="article"><meta property="og:title" content="Java线程池初探"><meta property="og:url" content="https://blog.mockingj.cn/cn/java%E5%B9%B6%E5%8F%91(7)/"><meta property="og:site_name" content="海&#039;s Blog"><meta property="og:description" content="简介 在日常的程序编写中，经常会用到一种思想——池化，也就是将资源整合成一个资源池并作统一的分配。在此文章中，线程池就是这一思想的具体体现。 在普通的线程创建中，是直接创建线程，会存在  频繁申请销毁资源 调度资源造成额外的损耗 无限申请资源和缺少内部资源管理等问题  为解决以上问题，采用池化的思想，将线程统一管理。使得单一线程可以在执行完一个任务后而不被销毁，并继续执行下一个任务。 在java中"><meta property="og:locale" content="cn"><meta property="og:image" content="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/IMG_1364.JPEG"><meta property="article:published_time" content="2021-11-17T16:00:00.000Z"><meta property="article:modified_time" content="2021-11-17T16:00:00.000Z"><meta property="article:author" content="Ceacar"><meta property="article:tag" content="java"><meta property="article:tag" content="java学习"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/IMG_1364.JPEG"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.mockingj.cn/cn/java%E5%B9%B6%E5%8F%91(7)/"},"headline":"Java线程池初探","image":[],"datePublished":"2021-11-17T16:00:00.000Z","dateModified":"2021-11-17T16:00:00.000Z","author":{"@type":"Person","name":"Ceacar"},"publisher":{"@type":"Organization","name":"海's Blog","logo":{"@type":"ImageObject","url":"https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/IMG_1703.jpeg"}},"description":"简介 在日常的程序编写中，经常会用到一种思想——池化，也就是将资源整合成一个资源池并作统一的分配。在此文章中，线程池就是这一思想的具体体现。 在普通的线程创建中，是直接创建线程，会存在  频繁申请销毁资源 调度资源造成额外的损耗 无限申请资源和缺少内部资源管理等问题  为解决以上问题，采用池化的思想，将线程统一管理。使得单一线程可以在执行完一个任务后而不被销毁，并继续执行下一个任务。 在java中"}</script><link rel="canonical" href="https://blog.mockingj.cn/cn/java%E5%B9%B6%E5%8F%91(7)/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="../../css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="../../index.html"><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/IMG_1703.jpeg" alt="海&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="../../index.html">Home</a><a class="navbar-item" href="../../archives">Archives</a><a class="navbar-item" href="../../categories">Categories</a><a class="navbar-item" href="../../tags">Tags</a><a class="navbar-item" href="../../about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/IMG_1364.JPEG" alt="Java线程池初探"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-11-17T16:00:00.000Z" title="2021/11/18 00:00:00">2021-11-18</time>发表</span><span class="level-item"><time dateTime="2021-11-17T16:00:00.000Z" title="2021/11/18 00:00:00">2021-11-18</time>更新</span><span class="level-item"><a class="link-muted" href="../../categories/java%E5%B9%B6%E5%8F%91/">java并发</a></span><span class="level-item">40 minutes读完 (大约5925个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java线程池初探</h1><div class="content"><h2 id="简介">简介</h2>
<p>在日常的程序编写中，经常会用到一种思想——池化，也就是将资源整合成一个资源池并作统一的分配。在此文章中，线程池就是这一思想的具体体现。</p>
<p>在普通的线程创建中，是直接创建线程，会存在</p>
<ul>
<li>频繁申请销毁资源</li>
<li>调度资源造成额外的损耗</li>
<li>无限申请资源和缺少内部资源管理等问题</li>
</ul>
<p>为解决以上问题，采用池化的思想，将线程统一管理。使得单一线程可以在执行完一个任务后而不被销毁，并继续执行下一个任务。</p>
<p>在java中提供了一种线程池框架，Executor框架</p>
<span id="more"></span>
<h2 id="线程池的设计">线程池的设计</h2>
<h3 id="线程池的基本处理流程如下">线程池的基本处理流程如下</h3>
<ol>
<li>线程池判断<strong>核心线程</strong>是否都在执行任务。若不是，则创建一个新的工作线程来执行任务。若核心线程池里的线程都在执行任务，则进入2</li>
<li>线程池判断<strong>工作队列</strong>是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入3。</li>
<li>线程池判断线程池的<strong>所有线程</strong>是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li>
</ol>
<p>以上流程如图所示：</p>
<p><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/00118.jpeg" alt="流程图"></p>
<h2 id="java中线程池的实现——Executor框架">java中线程池的实现——Executor框架</h2>
<p>Executor框架的主要继承和实现</p>
<p><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/9791ff62e46f409ba4f4cd73653e5271~tplv-k3u1fbpfcp-watermark.awebp" alt="Executor继承和实现"></p>
<p>从此图中可知，Executor框架的实现包含<code>ThreadPoolExecutor</code>、<code>DelegatedExecutorServoce</code>、<code>ForkJoinPool</code>等，他们都实现了<code>ExecutorService</code>接口</p>
<p>顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由<code>Executor</code>框架完成线程的调配和任务的执行部分。</p>
<p><code>ExecutorService</code>为Executor补充了可以为一个或一批异步任务生成<code>Future</code>的方法，以及管理线程池的方法。</p>
<p><code>ExecutorService</code>接口定义的特定行为：</p>
<ul>
<li><strong>execute(Runnable command)</strong>：履行Ruannable类型的任务；</li>
<li><strong>submit(task)</strong>：可用来提交Callable或Runnable任务，并返回代表此任务的Future对象；</li>
<li><strong>shutdown()</strong>：在完成已提交的任务后封闭办事，不再接管新任务；</li>
<li><strong>shutdownNow()</strong>：停止所有正在履行的任务并封闭办事；</li>
<li><strong>isTerminated()</strong>：测试是否所有任务都履行完毕了；</li>
<li><strong>isShutdown()</strong>：测试是否该ExecutorService已被关闭;</li>
<li><strong>awaitTermination(long,TimeUnit)</strong>：接收timeout和TimeUnit两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测ExecutorService是否已经关闭，若关闭则返回true，否则返回false。一般情况下会和shutdown方法组合使用;</li>
<li><strong>invokeAll</strong> ：作用是等待所有的任务执行完成后统一返回;</li>
<li><strong>invokeAny</strong> ：将第一个得到的结果作为返回值，然后立刻终止所有的线程。如果设置了超时时间，未超时完成则正常返回结果，如果超时未完成则报超时异常。</li>
</ul>
<p>在使用时，只需要看接口的方法说明就好，但是在实际的分析中，需要着眼于其中一个常用实现进行具体的分析和理解</p>
<h2 id="线程池的具体实现原理——ThreadPoolExecutor">线程池的具体实现原理——ThreadPoolExecutor</h2>
<h3 id="生产者消费者模型">生产者消费者模型</h3>
<p>线程池的内部定义了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。</p>
<p>线程池主要分为两大功能模块，任务管理和线程管理。</p>
<p><strong>任务管理</strong>部分充当生产者角色，在用户提交任务后，执行任务的流转：</p>
<ol>
<li>直接申请线程执行任务</li>
<li>加入缓冲队列</li>
<li>拒绝任务</li>
</ol>
<p><strong>线程管理</strong>部分是消费者，被统一维护在线程池内，根据请求对线程进行分配，或者对线程进行回收。</p>
<p>线程池运行机制如图</p>
<p><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/77441586f6b312a54264e3fcf5eebe2663494.png" alt=""></p>
<h3 id="线程池的基本组成部分">线程池的基本组成部分</h3>
<ol>
<li>线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；</li>
<li>工作线程（WorkThread）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；</li>
<li>任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；</li>
<li>任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。</li>
</ol>
<h3 id="线程池状态">线程池状态</h3>
<p>ThreadPoolExecutor使用一个变量标记线程池的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>它同时包含两部分的信息：线程池的<strong>运行状态 (runState)</strong> 和线程池内<strong>有效线程的数量 (workerCount)</strong>，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。</p>
<blockquote>
<p>用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。</p>
</blockquote>
<p>关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="comment">//计算当前运行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;  <span class="comment">//计算当前线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;   <span class="comment">//通过状态和线程数生成ctl</span></span><br></pre></td></tr></table></figure>
<p>线程池的运行状态及其变化</p>
<p><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/62853fa44bfa47d63143babe3b5a4c6e82532.png" alt="状态"></p>
<p><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/582d1606d57ff99aa0e5f8fc59c7819329028.png" alt="变化"></p>
<h3 id="线程池任务调度">线程池任务调度</h3>
<h4 id="相关参数">相关参数</h4>
<p><strong>corePoolSize</strong></p>
<p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p>
<p><strong>maximumPoolSize</strong></p>
<p>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；</p>
<p><strong>keepAliveTim</strong></p>
<p>线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</p>
<h4 id="具体实现">具体实现</h4>
<p>首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p>
<ol>
<li>首先检测线程池运行状态，如果不是<strong>RUNNING</strong>状态，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li>
<li>如果<code>workerCount</code> &lt; <code>corePoolSize</code>，则<strong>创建并启动一个线程</strong>来执行新提交的任务。</li>
<li>如果<code>workerCount</code> &gt;= <code>corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果<code>workerCount</code> &gt;= <code>corePoolSize</code> &amp;&amp; <code>workerCount</code> &lt; <code>maximumPoolSize</code>，且线程池内的阻塞队列已满，则创<strong>建并启动一个线程</strong>来执行新提交的任务。</li>
<li>如果<code>workerCount</code> &gt;= <code>maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p>其执行流程如下图所示：</p>
<p><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/31bad766983e212431077ca8da92762050214.png" alt=""></p>
<h3 id="任务缓冲与阻塞队列">任务缓冲与阻塞队列</h3>
<p>任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个<strong>阻塞队列</strong>来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p>
<h4 id="阻塞队列">阻塞队列</h4>
<p>BlockingQueue 通常用于一个线程生产对象，而另外一个线程消费这些对象的场景。下图是对这个原理的阐述:</p>
<p><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/java-thread-x-blocking-queue-1.png" alt="阻塞队列"></p>
<p>一个线程往里边放，另外一个线程从里边取的一个 BlockingQueue。</p>
<p>一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。 负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。</p>
<p>线程池中使用不同的阻塞队列可以实现不一样的任务存取策略。</p>
<p><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/725a3db5114d95675f2098c12dc331c3316963.png" alt="阻塞队列"></p>
<h3 id="任务申请">任务申请</h3>
<p>在任务提交后，任务的执行会有两种可能的执行方式：</p>
<ol>
<li>任务直接由新创建的线程执行</li>
<li>线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。</li>
</ol>
<p>线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。</p>
<p><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/49d8041f8480aba5ef59079fcc7143b996706.png" alt="getTask"></p>
<p>getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。</p>
<h3 id="任务拒绝和拒绝策略">任务拒绝和拒绝策略</h3>
<p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p>
<p>拒绝策略有一个接口，用户可以定制拒绝策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java提供的拒绝策略</p>
<p><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/9ffb64cc4c64c0cb8d38dac01c89c905178456.png" alt="拒绝策略"></p>
<h3 id="Worker线程管理">Worker线程管理</h3>
<p>线程池内的worker，实现了Runnable，并持有一个Thread线程，一个初始化的任务firstTask。通过worker来对线程进行管理。</p>
<p>Worker执行任务的模型如下图所示：</p>
<p><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/03268b9dc49bd30bb63064421bb036bf90315.png" alt="Worker执行任务"></p>
<p>Worker是通过继承AQS，实现不可重入的独占锁。</p>
<ol>
<li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中。</li>
<li>如果正在执行任务，则不应该中断线程。</li>
<li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。</li>
<li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</li>
</ol>
<p>在线程回收过程中就使用到了这种特性，回收过程如下图所示：</p>
<p><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/9d8dc9cebe59122127460f81a98894bb34085.png" alt="线程池回收过程"></p>
<p><strong>Worker线程的增加</strong></p>
<p>增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。</p>
<p><strong>Worker线程回收</strong></p>
<p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。</p>
<p>Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p>
<p><strong>Worker执行任务</strong></p>
<p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：</p>
<ol>
<li>while循环不断地通过getTask()方法获取任务。</li>
<li>getTask()方法从阻塞队列中取任务。</li>
<li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。</li>
<li>执行任务。</li>
<li>如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。</li>
</ol>
<h3 id="不同类型的线程池">不同类型的线程池</h3>
<p>在使用不同的阻塞队列和线程池参数，可以将线程池定义为某些特定性质或类型的线程池，使用ThreadPoolExecutor内部的静态方法进行创建</p>
<p><strong>newFixedThreadPool（固定大小线程池）</strong></p>
<p>newFixedThreadPool：创建一个核心线程个数和最大线程个数都为 nThreads 的线程池，并且阻塞队列长度为 <code>Integer.MAX_VALUE</code>，<code>keeyAliveTime=0</code> 说明只要线程个数比核心线程个数多并且当前空闲则回收。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//使用自定义线程创建工厂</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>newSingleThreadExecutor(单个后台线程）</strong></p>
<p>newSingleThreadExecutor：创建一个核心线程个数和最大线程个数都为1的线程池，并且阻塞队列长度为 <code>Integer.MAX_VALUE</code>，<code>keeyAliveTime=0</code> 说明只要线程个数比核心线程个数多并且当前空闲则回收。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自己的线程工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>newCachedThreadPool（无界线程池，可以进行自动线程回收）</strong></p>
<p>newCachedThreadPool：创建一个按需创建线程的线程池，初始线程个数为 0，最多线程个数为 <code>Integer.MAX_VALUE</code>，并且阻塞队列为同步队列，<code>keeyAliveTime=60</code> 说明只要当前线程 60s 内空闲则回收。这个特殊在于加入到同步队列的任务会被马上被执行，同步队列里面最多只有一个任务。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自定义的线程工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>newScheduledThreadPool (可调度)</strong></p>
<p>newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。newScheduledThreadPool 和 其他线程池最大的区别是使用的阻塞队列是 DelayedWorkQueue，而且多了两个定时执行的方法scheduleAtFixedRate和scheduleWithFixedDelay</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自定义的线程工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> corePoolSize, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>newWorkStealingPool（并行操作）</strong></p>
<p>newWorkStealingPool：JDK1.8新增newWorkStealingPool，适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类ForkJoinPool的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span></span><br><span class="line">            (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span></span><br><span class="line">            (parallelism,</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java线程池的使用">Java线程池的使用</h2>
<h3 id="Java中创建线程的三种方式">Java中创建线程的三种方式</h3>
<p><strong>1、继承Thread类创建线程类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstThreadTest</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//重写run方法，run方法的方法体就是现场执行体  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;  &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、通过Runnable接口创建线程类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableThreadTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(rtt, <span class="string">&quot;新线程2&quot;</span>).start();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、通过Callable和Future创建线程</strong></p>
<p>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。（FutureTask是一个包装器，它通过接受Callable来创建，它同时实现了Future和Runnable接口。）</li>
<li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li>
<li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   FutureTask&lt;Integer&gt; integerFutureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Thread</span>(integerFutureTask).start();</span><br><span class="line">   integerFutureTask.get();</span><br></pre></td></tr></table></figure>
<p>这种离散的线程创建方式会导致服务由于资源不足而导致宕机。</p>
<h2 id="线程池创建方式">线程池创建方式</h2>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池:</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);<span class="comment">//申请一个线程池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池:</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start task &quot;</span> + name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end task &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Java通过Executors提供四种线程池">Java通过Executors提供四种线程池</h3>
<p><strong>newFixedThreadPool</strong>：创建一个固定大小的线程池，提交一个任务就在线程池中创建一个线程，直到线程数量达到线程池最大限制。线程池一旦到最大就不会再改变，除非有已经开启的线程出现异常，再提交任务时会继续新建线程。这个创建线程池的方法是在实际项目中比较常用的，由于corePoolSize和maximumPoolSize两个参数是相同大小，所以到了线程池最大容量后，如果有任务完成让出占用线程，那么此线程就会一直处于等待状态，而不会消亡，直到下一个任务再次占用该线程。<strong>此方法的弊端是：使用无界队列来存放排队任务，当大量任务超过线程池最大容量需要处理时，队列无线增大，使服务器资源迅速耗尽。</strong></p>
<p><strong>newCachedThreadPool</strong>：创建一个可根据实际情况调整大小的线程池，线程数量不确定，只要有空闲线程空闲时间超过keepAliveTime，就会干掉，再来新任务，先使用空闲线程，若不够，再新建线程。<strong>线程池没有最大线程数量限制，所以当大量线程蜂拥而至，会造成资源耗尽</strong>。</p>
<p><strong>newSingleThreadExecutor</strong>：创建一个容量为1的线程池，被提交任务按优先级依次执行。<strong>但是任务队列是无界的LinkedBlockingQueue，存在任务队列无限添加造成OOM的风险。</strong></p>
<p><strong>newScheduledThreadPool</strong>：创建一个定长线程池，长度为输入参数自定义，支持定时周期任务执行，可根据时间需要在指定时间对线程进行调度。<strong>这个线程池的最大线程数也是Integer.MAX_VALUE，可以理解为会无限创建线程。存在将资源耗尽的风险。</strong></p>
<p><strong>不建议使用 Executors来创建线程池！！！请使用ThreadPoolExecutor的方式创建</strong></p>
<h2 id="线程池应用场景">线程池应用场景</h2>
<p><strong>高并发、任务执行时间短的业务怎样使用线程池？</strong></p>
<blockquote>
<p>线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p>
</blockquote>
<p><strong>并发不高、任务执行时间长的业务怎样使用线程池？</strong></p>
<blockquote>
<p>这个需要判断执行时间是耗在哪个地方</p>
<ul>
<li>假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目（2 * CPU核数），让CPU处理更多的业务。</li>
<li>假如是业务时间长集中在计算操作上，也就是CPU密集型任务，和（1）CPU核数+1 一样，线程池中的线程数设置得少一些，减少线程上下文的切换</li>
</ul>
</blockquote>
<p><strong>并发高、业务执行时间长的业务怎样使用线程池？</strong></p>
<blockquote>
<p>解决这种类型任务的关键不在于线程池而在于整体架构的设计</p>
</blockquote>
<h2 id="参考文档">参考文档</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-BlockingQueue.html">https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-BlockingQueue.html</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6903548111344369672">https://juejin.cn/post/6903548111344369672</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903634975768590">https://juejin.cn/post/6844903634975768590</a></li>
</ul>
<p><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/IMG_1370.JPEG" alt="风景"></p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="../../tags/java/">java</a><a class="link-muted mr-2" rel="tag" href="../../tags/java%E5%AD%A6%E4%B9%A0/">java学习</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="../java%E5%B9%B6%E5%8F%91(8)/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">ForkJoin框架</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="../java%E5%B9%B6%E5%8F%91(6)/"><span class="level-item">ConcurrentLinkedQueue学习总结</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#简介"><span class="level-left"><span class="level-item">1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#线程池的设计"><span class="level-left"><span class="level-item">2</span><span class="level-item">线程池的设计</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#线程池的基本处理流程如下"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">线程池的基本处理流程如下</span></span></a></li></ul></li><li><a class="level is-mobile" href="#java中线程池的实现——Executor框架"><span class="level-left"><span class="level-item">3</span><span class="level-item">java中线程池的实现——Executor框架</span></span></a></li><li><a class="level is-mobile" href="#线程池的具体实现原理——ThreadPoolExecutor"><span class="level-left"><span class="level-item">4</span><span class="level-item">线程池的具体实现原理——ThreadPoolExecutor</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#生产者消费者模型"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">生产者消费者模型</span></span></a></li><li><a class="level is-mobile" href="#线程池的基本组成部分"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">线程池的基本组成部分</span></span></a></li><li><a class="level is-mobile" href="#线程池状态"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">线程池状态</span></span></a></li><li><a class="level is-mobile" href="#线程池任务调度"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">线程池任务调度</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#相关参数"><span class="level-left"><span class="level-item">4.4.1</span><span class="level-item">相关参数</span></span></a></li><li><a class="level is-mobile" href="#具体实现"><span class="level-left"><span class="level-item">4.4.2</span><span class="level-item">具体实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#任务缓冲与阻塞队列"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">任务缓冲与阻塞队列</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#阻塞队列"><span class="level-left"><span class="level-item">4.5.1</span><span class="level-item">阻塞队列</span></span></a></li></ul></li><li><a class="level is-mobile" href="#任务申请"><span class="level-left"><span class="level-item">4.6</span><span class="level-item">任务申请</span></span></a></li><li><a class="level is-mobile" href="#任务拒绝和拒绝策略"><span class="level-left"><span class="level-item">4.7</span><span class="level-item">任务拒绝和拒绝策略</span></span></a></li><li><a class="level is-mobile" href="#Worker线程管理"><span class="level-left"><span class="level-item">4.8</span><span class="level-item">Worker线程管理</span></span></a></li><li><a class="level is-mobile" href="#不同类型的线程池"><span class="level-left"><span class="level-item">4.9</span><span class="level-item">不同类型的线程池</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Java线程池的使用"><span class="level-left"><span class="level-item">5</span><span class="level-item">Java线程池的使用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Java中创建线程的三种方式"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">Java中创建线程的三种方式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#线程池创建方式"><span class="level-left"><span class="level-item">6</span><span class="level-item">线程池创建方式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Java通过Executors提供四种线程池"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">Java通过Executors提供四种线程池</span></span></a></li></ul></li><li><a class="level is-mobile" href="#线程池应用场景"><span class="level-left"><span class="level-item">7</span><span class="level-item">线程池应用场景</span></span></a></li><li><a class="level is-mobile" href="#参考文档"><span class="level-left"><span class="level-item">8</span><span class="level-item">参考文档</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="../../js/toc.js" defer></script></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="../../tags/Hive%E5%BC%80%E5%8F%91/"><span class="tag">Hive开发</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/blog/"><span class="tag">blog</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/go/"><span class="tag">go</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/hugo/"><span class="tag">hugo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/java/"><span class="tag">java</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/java%E5%AD%A6%E4%B9%A0/"><span class="tag">java学习</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/java%E5%BC%80%E5%8F%91/"><span class="tag">java开发</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/mybaits/"><span class="tag">mybaits</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/springboot/"><span class="tag">springboot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/%E9%9A%8F%E6%83%B3/"><span class="tag">随想</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="../../index.html"><img src="https://mockingjay-1257222092.cos.ap-guangzhou.myqcloud.com/IMG_1703.jpeg" alt="海&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Ceacar</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="../../js/column.js"></script><script src="../../js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><script src="../../js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="../../js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"../../content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>